
#include "math_fcn.hpp"

namespace canal {
namespace math {
template<class T>
const T abs_fun(T& v) {
return v > 0 ? v : -v;
}

/*
template<class T>
const T Abs(Complex<T>&c)
{
  
  T a = std::sqrt( abs2(c) );
  return a;
}
*/



template<class T>
T exp_fun(const T& x) {
  // when x is large in magnitude, exp(x) is approximated by picking
  // some sufficiently large integer m
  // such that x/2^m is sufficiently small in magnitude
  const int k = 10;
  T xx = x;
  int m = 0;

  while (abs_fun(xx) > 0.5) {
     xx /=2.;
     m++;
  }
  
  // in this way if T is a matrix, then sum is initialized to identity matrix
  T sum = T(1.0);
    
  for (int i = k; i > 0; i--) {
    sum *= xx/T(i);
    sum += T(1.);
  }
    
  for (int i = 0; i < m; i++)
    sum *= sum;
    
  return sum;
  
}


template<class T>
const canal::math::Complex<T> exp_fun(const canal::math::Complex<T>&c) {

      // ordinary exponetial value of real component of complex
      T exp_val = exp_fun(c.re());
      canal::math::Complex<T> euler_exp_val(std::cos(c.im()), -std::sin(c.im()));

      euler_exp_val *= exp_val;
      
      return euler_exp_val;
     
}


template<class T>
const canal::math::MathVector<canal::math::Complex<T>> exp_fun(
    const canal::math::MathVector<canal::math::Complex<T>>&v) {

  canal::math::MathVector<canal::math::Complex<T>> cplex_exp(v.get_dimension());
  
  for (unsigned int i = 0; i < v.get_dimension(); i++)
    cplex_exp.set(i, exp_fun(v[i]));

  return cplex_exp;
     
}




template<class T>
const T power_fun(const T& x, const unsigned int n) {

  return n > 0 ?
      (n > 1 ?
      (n%2 ? x * power_fun(x * x, n/2)
       :
       power_fun(x * x, n/2))
      :
       x)
      :1;
}
// Compute a power recursively



template<class T>
const canal::math::MathVector<T> power_fun(const T& base,
                                        const canal::math::MathVector<unsigned int>& v) {
  canal::math::MathVector<T> w(v.get_dimension());
  for (unsigned int i = 0; i < v.get_dimension(); i++)
    w.set(i, power_fun(base, v[i]) );

  return w;
  
}





unsigned int integer_log_fun(unsigned int n) {
  return n > 1 ? integer_log_fun(n/2)+1:0;
}

template<typename T>
const canal::math::MathVector< canal::math::Complex<T> > roots_fun(
    const canal::math::MathVector<T>&u) {
  
  int n = u.get_dimension() - 1, j = 0;
  canal::math::Matrix<T> c(n, n), m(n, n);
  canal::math::MathVector<T>v(u);
  canal::math::MathVector<canal::math::Complex<T>> e;

  v = v / (v[0]);
  // make cn = 1
  for (int i = 1; i < n; i++) {
    c.set_val(j, i, 1);
    j++;
  }

  j = 0;
  for (int i = n; i > 0; i--) {
    c.set_val(n-1, j, -v[i]);
    j++;
  }

  // Matrix library relies on EIGEN Matrix library to compute the roots
  e = canal::math::EigenVal(c);

  return e;
  
}



template<typename T>
canal::math::MathVector<T> cplex2real_fun(
    const canal::math::MathVector<canal::math::Complex<T>>&v) {
  unsigned int n = v.get_dimension();
  canal::math::MathVector<T> w(n);
  for (unsigned int i = 0; i < n; i++) {
    w.set(i, v[i].re() );
  }

  return w;
}

template<typename T>
const canal::math::MathVector<canal::math::Complex<T>> poly_fun(
    const canal::math::MathVector<canal::math::Complex<T>>&u) {

  unsigned int n = u.get_dimension();
  canal::math::Complex<T> c(T(1));
  canal::math::MathVector<canal::math::Complex<T>> cp_vec(n+1, 0, 0);
  cp_vec.set(0, c);
  for (unsigned int j = 0; j < n; j++) {
     canal::math::MathVector<canal::math::Complex<T>> vv(j+1);
     for (unsigned int k = 0; k < j+1; k++) {
      vv.set(k, cp_vec[k+1]-u[j]*cp_vec[k]);
     }
     for (unsigned int k = 0; k < j+1; k++) {
        cp_vec.set(k+1, vv[k]);
     }
  }
  
  return cp_vec;
}



template<typename T>
const canal::math::MathVector<T> poly_fun(const canal::math::MathVector<T>&u) {
  canal::math::Complex<T>cval;
  unsigned int n = u.get_dimension();
  canal::math::MathVector<T> p;
  canal::math::MathVector<T>v(u), c(n+1);

  c.set(0, 1);
  // Expand recursion formula
  for (unsigned int i = 0; i < n; i++) {
    canal::math::MathVector<T> vv(i+1);
    for (unsigned int j = 0; j < i+1; j++) {
      vv.set(j, c[j+1]-v[i]*c[j]);
    }

    for (unsigned int k = 0; k < i+1; k++) {
      c.set(k+1, vv[k]);
    }
  }
 
  return c;
}





template<typename T>
canal::math::MathVector<T> sin_fun(const canal::math::MathVector<T>& v) {

  int n = v.get_dimension();
  canal::math::MathVector<T> sine_vec(n);
 
  for (int i = 0; i < n; i++) {
    
    sine_vec.set(i, std::sin(v[i]));
  }

  return sine_vec;
 
}


template<typename T>
canal::math::MathVector<T> cos_fun(const canal::math::MathVector<T>& v) {
  int n = v.get_dimension();
  canal::math::MathVector<T> cos_vec(n);
  
  for (int i = 0; i < n; i++) {
    
    cos_vec.set(i, std::cos(v[i]));
  }
  
  return cos_vec;
  
}



template<typename T>
canal::math::MathVector<T> sqrt_fun(const canal::math::MathVector<T>& v) {
 int n = v.get_dimension();
 canal::math::MathVector<T> sqrt_vec(n);
 for (int i = 0; i < n; i++) {
   sqrt_vec.set(i, v[i]*=v[i]);
 }
 
 return sqrt_vec;
}

template<typename T>
canal::math::MathVector<canal::math::Complex<T>> sqrt_fun(const canal::math::MathVector<canal::math::Complex<T>>& v) {
 int n = v.get_dimension();
 canal::math::MathVector<canal::math::Complex<T>> sqrt_vec(n);
 for (int i = 0; i < n; i++) {
   sqrt_vec.set(i, canal::math::Complex<T>(v[i])*=v[i]);
 }
 
 return sqrt_vec;
}





template<typename T>
canal::math::MathVector<canal::math::Complex<T>> real2complex_fun(
    const canal::math::MathVector<T>&v, const canal::math::MathVector<T>&w) {
    throw_assert(v.get_dimension() == w.get_dimension(),
                "Vectors are not of same dimension");
 
    int n = v.get_dimension();
    canal::math::Complex<T> c;
    canal::math::MathVector<canal::math::Complex<T>> cvec(n);
   
    for (int i = 0; i < n; i++) {
      c.set_re(v[i]);
      c.set_im(w[i]);
      cvec.set(i, c);
    }
   
    return cvec;
    
}


 template<typename T>
  const canal::math::MathVector<canal::math::Complex<T>> operator/(const canal::math::MathVector<canal::math::Complex<T>>cplex_vec, const T& t) {
  
  return canal::math::MathVector<canal::math::Complex<T>>(cplex_vec) /= t;

}




}
}
//  End NameSpace








